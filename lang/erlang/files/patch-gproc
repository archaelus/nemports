diff --git a/lib/kernel/src/application_master.erl b/lib/kernel/src/application_master.erl
index 87addb1..afbbe5d 100644
--- a/lib/kernel/src/application_master.erl
+++ lib/kernel/src/application_master.erl
@@ -120,6 +120,7 @@ call(AppMaster, Req) ->
 init(Parent, Starter, ApplData, Type) ->
     link(Parent),
     process_flag(trap_exit, true),
+    gen:reg_behaviour(application),
     OldGleader = group_leader(),
     group_leader(self(), self()),
     %% Insert ourselves as master for the process.  This ensures that
diff --git a/lib/kernel/src/file.erl b/lib/kernel/src/file.erl
index c631aea..4e84a0c 100644
--- a/lib/kernel/src/file.erl
+++ lib/kernel/src/file.erl
@@ -395,7 +395,7 @@ close(_) ->
 	
 
 read(File, Sz) when is_pid(File), is_integer(Sz), Sz >= 0 ->
-    case io:request(File, {get_chars, "", Sz}) of
+    case io:request(File, {get_chars, '', Sz}) of
 	Data when is_list(Data); is_binary(Data) ->
 	    {ok, Data};
 	Other ->
@@ -1004,7 +1004,7 @@ consult_stream(Fd) ->
     consult_stream(Fd, 1, []).
 
 consult_stream(Fd, Line, Acc) ->
-    case io:read(Fd, "", Line) of
+    case io:read(Fd, '', Line) of
 	{ok,Term,EndLine} ->
 	    consult_stream(Fd, EndLine, [Term|Acc]);
 	{error,Error,_Line} ->
diff --git a/lib/kernel/src/gen_leader.erl b/lib/kernel/src/gen_leader.erl
new file mode 100644
index 0000000..ce7907b
--- /dev/null
+++ lib/kernel/src/gen_leader.erl
@@ -0,0 +1,1076 @@
+%% ``The contents of this file are subject to the Erlang Public License,
+%% Version 1.1, (the "License"); you may not use this file except in
+%% compliance with the License. You should have received a copy of the
+%% Erlang Public License along with this software. If not, it can be
+%% retrieved via the world wide web at http://www.erlang.org/.
+%% 
+%% Software distributed under the License is distributed on an "AS IS"
+%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+%% the License for the specific language governing rights and limitations
+%% under the License.
+%% 
+%% The Initial Developer of the Original Code is Ericsson Utvecklings AB.
+%% Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings
+%% AB. All Rights Reserved.''
+%%
+%% @author Ulf Wiger <ulf.wiger@ericsson.com>
+%% @author Thomas Arts <thomas.arts@ituniv.se>
+%% 
+%% @doc Leader election behaviour.
+%% <p>This application implements a leader election behaviour modeled after
+%% gen_server. This behaviour intends to make it reasonably
+%% straightforward to implement a fully distributed server with
+%% master-slave semantics.</p>
+%% <p>The gen_leader behaviour supports nearly everything that gen_server
+%% does (some functions, such as multicall() and the internal timeout,
+%% have been removed), and adds a few callbacks and API functions to 
+%% support leader election etc.</p>
+%% <p>Also included is an example program, a global dictionary, based
+%% on the modules gen_leader and dict. The callback implementing the
+%% global dictionary is called 'test_cb', for no particularly logical
+%% reason.</p>
+%% @end
+%%
+%% @type election() = tuple(). Opaque state of the gen_leader behaviour.
+%% @type node() = atom(). A node name.
+%% @type name() = atom(). A locally registered name.
+%% @type serverRef() = Name | {name(),node()} | {global,Name} | pid(). 
+%%   See gen_server.
+%% @type callerRef() = {pid(), reference()}. See gen_server.
+%%
+-module(gen_leader).
+
+
+-export([start/4, start/6,
+	 start_link/4, start_link/6,
+	 leader_call/2, leader_call/3, leader_cast/2,
+	 call/2, call/3, cast/2,
+	 reply/2]).
+
+%% Query functions
+-export([alive/1,
+	 down/1,
+	 candidates/1,
+	 workers/1]).
+
+-export([
+	 system_continue/3,
+	 system_terminate/4,
+	 system_code_change/4,
+	 format_status/2
+	]).
+
+-export([behaviour_info/1]).
+
+%% Internal exports
+-export([init_it/6, print_event/3
+	 %%, safe_send/2
+	]).
+
+-import(error_logger , [format/2]).
+-import(lists, [foldl/3,
+		foreach/2,
+		member/2,
+		keydelete/3,
+		keysearch/3,
+		keymember/3]).
+
+
+-record(election,{leader = none,
+		  mode = global,
+		  name,
+		  leadernode = none,
+		  candidate_nodes = [],	
+		  worker_nodes = [],
+		  alive = [],
+		  iteration,
+		  down = [],
+		  monitored = [],
+		  buffered = []
+		 }).
+
+-record(server, {parent,
+		 mod,
+		 state,
+		 debug}).
+
+%%% ---------------------------------------------------
+%%% Interface functions.
+%%% ---------------------------------------------------
+
+%% @hidden
+behaviour_info(callbacks) ->
+    [{init,1},
+     {elected,2},
+     {surrendered,3},
+     {handle_leader_call,4},
+     {handle_leader_cast,3},
+     {handle_local_only, 4},
+     {from_leader,3},
+     {handle_call,3},
+     {handle_cast,2},
+     {handle_DOWN,3},
+     {handle_info,2},
+     {terminate,2},
+     {code_change,4}];
+behaviour_info(_Other) ->
+    undefined.
+
+start(Name, Mod, Arg, Options) when is_atom(Name) ->
+    gen:start(?MODULE, nolink, {local,Name},
+	      Mod, {local_only, Arg}, Options).
+
+%% @spec start(Name::node(), CandidateNodes::[node()],
+%%             Workers::[node()], Mod::atom(), Arg, Options::list()) ->
+%%    {ok,pid()}
+%%
+%% @doc Starts a gen_leader process without linking to the parent.
+%%
+start(Name, [_|_] = CandidateNodes, Workers, Mod, Arg, Options)
+  when is_atom(Name) ->
+    gen:start(?MODULE, nolink, {local,Name},
+	      Mod, {CandidateNodes, Workers, Arg}, Options).
+
+%% @spec start_link(Name::atom(), CandidateNodes::[atom()],
+%%             Workers::[atom()], Mod::atom(), Arg, Options::list()) ->
+%%  {ok, pid()}
+%%
+%% @doc Starts a gen_leader process.
+%% <table>
+%%  <tr><td>Name</td><td>The locally registered name of the process</td></tr>
+%%  <tr><td>CandidateNodes</td><td>The names of nodes capable of assuming
+%%     a leadership role</td></tr>
+%%  <tr><td>Workers</td>
+%%     <td>The names of nodes that will be part of the "cluster",
+%%         but cannot ever assume a leadership role.</td></tr>
+%%  <tr><td>Mod</td><td>The name of the callback module</td></tr>
+%%  <tr><td>Arg</td><td>Argument passed on to <code>Mod:init/1</code></td></tr>
+%%  <tr><td>Options</td><td>Same as gen_server's Options</td></tr>
+%% </table>
+%%
+%% <p>The list of candidates needs to be known from the start. Workers 
+%% can be added at runtime.</p>
+%% @end
+start_link(Name, [_|_] = CandidateNodes, Workers, 
+	   Mod, Arg, Options) when is_atom(Name) ->
+    gen:start(?MODULE, link, {local,Name}, Mod,
+	      {CandidateNodes, Workers, Arg}, Options).
+
+start_link(Name, Mod, Arg, Options) when is_atom(Name) ->
+    gen:start(?MODULE, link, {local,Name}, Mod,
+	      {local_only, Arg}, Options).
+
+%% Query functions to be used from the callback module
+
+%% @spec alive(E::election()) -> [node()]
+%%
+%% @doc Returns a list of live nodes (candidates and workers).
+%%
+alive(#election{alive = Alive}) ->
+    Alive.
+
+%% @spec down(E::election()) -> [node()]
+%%
+%% @doc Returns a list of candidates currently not running.
+%%
+down(#election{down = Down}) ->
+    Down.
+
+%% @spec candidates(E::election()) -> [node()]
+%%
+%% @doc Returns a list of known candidates.
+%%
+candidates(#election{candidate_nodes = Cands}) ->
+    Cands.
+
+%% @spec workers(E::election()) -> [node()]
+%%
+%% @doc Returns a list of known workers.
+%%
+workers(#election{worker_nodes = Workers}) ->
+    Workers.
+
+%% @spec call(Name::serverRef(), Request) -> term()
+%%
+%% @doc Equivalent to <code>gen_server:call/2</code>, but with a slightly
+%% different exit reason if something goes wrong. This function calls 
+%% the <code>gen_leader</code> process exactly as if it were a gen_server
+%% (which, for practical purposes, it is.)
+%% @end
+call(Name, Request) ->
+    case catch gen:call(Name, '$gen_call', Request) of
+	{ok,Res} ->
+	    Res;
+	{'EXIT',Reason} ->
+	    exit({Reason, {?MODULE, local_call, [Name, Request]}})
+    end.
+
+%% @spec call(Name::serverRef(), Request, Timeout::integer()) ->
+%%     Reply
+%%
+%%     Reply = term()
+%%
+%% @doc Equivalent to <code>gen_server:call/3</code>, but with a slightly
+%% different exit reason if something goes wrong. This function calls 
+%% the <code>gen_leader</code> process exactly as if it were a gen_server
+%% (which, for practical purposes, it is.)
+%% @end
+call(Name, Request, Timeout) ->
+    case catch gen:call(Name, '$gen_call', Request, Timeout) of
+	{ok,Res} ->
+	    Res;
+	{'EXIT',Reason} ->
+	    exit({Reason, {?MODULE, local_call, [Name, Request, Timeout]}})
+    end.
+
+%% @spec leader_call(Name::name(), Request::term())
+%%    -> Reply
+%%
+%%    Reply = term()
+%%
+%% @doc Makes a call (similar to <code>gen_server:call/2</code>) to the 
+%% leader. The call is forwarded via the local gen_leader instance, if 
+%% that one isn't actually the leader. The client will exit if the 
+%% leader dies while the request is outstanding.
+%% <p>This function uses <code>gen:call/3</code>, and is subject to the
+%% same default timeout as e.g. <code>gen_server:call/2</code>.</p>
+%% @end
+%%
+leader_call(Name, Request) ->
+    case catch gen:call(Name, '$leader_call', Request) of
+	{ok,{leader,reply,Res}} ->
+	    Res;
+	{ok,{error, leader_died}} ->
+	    exit({leader_died, {?MODULE, leader_call, [Name, Request]}});
+	{'EXIT',Reason} ->
+	    exit({Reason, {?MODULE, leader_call, [Name, Request]}})
+    end.
+
+%% @spec leader_call(Name::name(), Request::term(), Timeout::integer())
+%%    -> Reply
+%%
+%%    Reply = term()
+%%
+%% @doc Makes a call (similar to <code>gen_server:call/3</code>) to the 
+%% leader. The call is forwarded via the local gen_leader instance, if 
+%% that one isn't actually the leader. The client will exit if the 
+%% leader dies while the request is outstanding.
+%% @end
+%%
+leader_call(Name, Request, Timeout) ->
+    case catch gen:call(Name, '$leader_call', Request, Timeout) of
+	{ok,{leader,reply,Res}} ->
+	    Res;
+	{ok,{error, leader_died}} ->
+	    exit({leader_died, {?MODULE, leader_call, [Name, Request]}});
+	{'EXIT',Reason} ->
+	    exit({Reason, {?MODULE, leader_call, [Name, Request, Timeout]}})
+    end.
+
+
+
+%% @equiv gen_server:cast/2
+cast(Name, Request) ->
+    catch do_cast('$gen_cast', Name, Request),
+    ok.
+
+%% @spec leader_cast(Name::name(), Msg::term()) -> ok
+%% @doc Similar to <code>gen_server:cast/2</code> but will be forwarded to
+%% the leader via the local gen_leader instance.
+leader_cast(Name, Request) ->
+    catch do_cast('$leader_cast', Name, Request),
+    ok.
+
+
+do_cast(Tag, Name, Request) when atom(Name) ->
+    Name ! {Tag, Request};
+do_cast(Tag, Pid, Request) when pid(Pid) ->
+    Pid ! {Tag, Request}.
+
+
+%% @spec reply(From::callerRef(), Reply::term()) -> Void
+%% @equiv gen_server:reply/2
+reply({To, Tag}, Reply) ->
+    catch To ! {Tag, Reply}.
+
+
+%%% ---------------------------------------------------
+%%% Initiate the new process.
+%%% Register the name using the Rfunc function
+%%% Calls the Mod:init/Args function.
+%%% Finally an acknowledge is sent to Parent and the main
+%%% loop is entered.
+%%% ---------------------------------------------------
+%%% @hidden
+init_it(Starter, self, Name, Mod, {CandidateNodes, Workers, Arg}, Options) ->
+    if CandidateNodes == [] ->
+	    erlang:error(no_candidates);
+       true ->
+	    init_it(Starter, self(), Name, Mod, 
+		    {CandidateNodes, Workers, Arg}, Options)
+    end;
+init_it(Starter,Parent,Name,Mod,{local_only, _}=Arg,Options) ->
+    Debug = debug_options(Name, Options),
+    reg_behaviour(),
+    case catch Mod:init(Arg) of
+	{stop, Reason} ->
+	    proc_lib:init_ack(Starter, {error, Reason}),
+	    exit(Reason);
+	ignore ->
+	    proc_lib:init_ack(Starter, ignore),
+	    exit(normal);
+	{'EXIT', Reason} ->
+	    proc_lib:init_ack(Starter, {error, Reason}),
+	    exit(Reason);
+	{ok, State} ->
+	    proc_lib:init_ack(Starter, {ok, self()}),
+	    Server = #server{parent = Parent,
+			     mod = Mod,
+			     state = State,
+			     debug = Debug},
+	    loop(Server, local_only, #election{name = Name, mode = local});
+	Other ->
+	    Error = {bad_return_value, Other},
+	    proc_lib:init_ack(Starter, {error, Error}),
+	    exit(Error)
+    end;
+init_it(Starter,Parent,Name,Mod,{CandidateNodes,Workers,Arg},Options) ->
+    Debug = debug_options(Name, Options),
+    reg_behaviour(),
+    AmCandidate = member(node(), CandidateNodes),
+    Election = init_election(CandidateNodes, Workers, #election{name = Name}),
+    case {catch Mod:init(Arg), AmCandidate} of
+	{{stop, Reason},_} ->
+	    proc_lib:init_ack(Starter, {error, Reason}),
+	    exit(Reason);
+	{ignore,_} ->
+	    proc_lib:init_ack(Starter, ignore),
+	    exit(normal);
+	{{'EXIT', Reason},_} ->
+	    proc_lib:init_ack(Starter, {error, Reason}),
+	    exit(Reason);
+	{{ok, State}, true} ->
+%%%	    NewE = broadcast(capture,Workers++(CandidateNodes -- [node()]),
+%%%			     Election),
+	    proc_lib:init_ack(Starter, {ok, self()}), 	  
+	    begin_election(#server{parent = Parent,
+				   mod = Mod,
+				   state = State,
+				   debug = Debug}, candidate, Election);
+	{{ok, State}, false} ->
+%%%	    NewE = broadcast(add_worker, CandidateNodes, Election),
+	    proc_lib:init_ack(Starter, {ok, self()}),
+	    begin_election(#server{parent = Parent,
+				   mod = Mod,
+				   state = State,
+				   debug = Debug}, waiting_worker, Election);
+	Else ->
+	    Error = {bad_return_value, Else},
+	    proc_lib:init_ack(Starter, {error, Error}),
+	    exit(Error)
+    end.
+
+reg_behaviour() ->
+    catch gproc:reg({p,l,behaviour}, ?MODULE).
+
+init_election(CandidateNodes, Workers, E) ->
+%%%    dbg:tracer(),
+%%%    dbg:tpl(?MODULE,lexcompare,[]),
+%%%    dbg:p(self(),[m,c]),
+    AmCandidate = member(node(), CandidateNodes),
+    case AmCandidate of
+	true ->
+	    E#election{mode = global,
+		       candidate_nodes = CandidateNodes,
+		       worker_nodes = Workers,
+		       iteration = {[], 
+				    position(
+				      node(),CandidateNodes)}};
+	false ->
+	    E#election{mode = global,
+		       candidate_nodes = CandidateNodes,
+		       worker_nodes = Workers}
+    end.
+
+begin_election(#server{mod = Mod, state = State} = Server, candidate,
+	       #election{candidate_nodes = Cands,
+			 worker_nodes = Workers} = E) ->
+    case Cands of
+	[N] when N == node() ->
+	    {ok, Synch, NewState} = Mod:elected(State, E),
+	    NewE = broadcast({elect,Synch}, E),
+	    loop(Server#server{state = NewState}, elected, NewE);
+	_ ->
+	    NewE = broadcast(capture,Workers++(Cands -- [node()]), E),
+	    safe_loop(Server, candidate, NewE)
+    end;
+begin_election(Server, waiting_worker, #election{candidate_nodes = Cands}=E) ->
+    NewE = broadcast(add_worker, Cands, E),
+    safe_loop(Server, waiting_worker, NewE).
+    
+
+%%% ---------------------------------------------------
+%%% The MAIN loop.
+%%% ---------------------------------------------------
+
+
+safe_loop(#server{mod = Mod, state = State} = Server, Role,
+	  #election{name = Name} = E) ->
+    receive
+	{system, From, Req} ->
+	    #server{parent = Parent, debug = Debug} = Server,
+	    sys:handle_system_msg(Req, From, Parent, ?MODULE, Debug,
+				  [safe, Server, Role, E]);
+	{'EXIT', _Parent, Reason} = Msg ->
+	    terminate(Reason, Msg, Server, Role, E);
+	{leader,capture,Iteration,_Node,Candidate} ->
+	    case Role of
+		candidate ->
+		    NewE =
+			nodeup(node(Candidate),E),
+		    case lexcompare(NewE#election.iteration,Iteration) of
+			less ->
+			    Candidate ! 
+				{leader,accept,
+				 NewE#election.iteration,self()},
+			    safe_loop(Server, captured, 
+				      NewE#election{leader = Candidate});
+			greater ->
+			    %% I'll get either an accept or DOWN
+			    %% from Candidate later
+			    safe_loop(Server, Role, NewE);
+			equal ->
+			    safe_loop(Server, Role, NewE)
+		    end;
+		captured ->
+		    NewE = nodeup(node(Candidate), E),
+		    safe_loop(Server, Role, NewE);
+		waiting_worker ->
+		    NewE = 
+			nodeup(node(Candidate),E),
+		    safe_loop(Server, Role, NewE)
+	    end;
+	{leader,add_worker,Worker} ->
+	    NewE = nodeup(node(Worker), E),
+	    safe_loop(Server, Role, NewE);
+	{leader,accept,Iteration,Candidate} ->
+	    case Role of
+		candidate ->
+		    NewE =
+			nodeup(node(Candidate),E),
+		    {Captured,_} = Iteration,
+		    NewIteration =   % inherit all procs that have been
+				     % accepted by Candidate
+			foldl(fun(C,Iter) ->
+				      add_captured(Iter,C)
+			      end,NewE#election.iteration,
+			      [node(Candidate)|Captured]),
+		    check_majority(NewE#election{
+				     iteration = NewIteration}, Server);
+		captured ->
+		    %% forward this to the leader
+		    E#election.leader ! {leader,accept,Iteration,Candidate},
+		    NewE = nodeup(node(Candidate), E),
+		    safe_loop(Server, Role, NewE)
+	    end;
+	{leader,elect,Synch,Candidate} ->
+	    NewE = 
+		case Role of
+		    waiting_worker ->
+			nodeup(node(Candidate),
+			       E#election{
+				 leader = Candidate,
+				 leadernode = node(Candidate)});
+		    _ ->
+			nodeup(node(Candidate),
+			       E#election{
+				 leader = Candidate,
+				 leadernode = node(Candidate),
+				 iteration = {[],
+					      position(
+						node(),
+						E#election.candidate_nodes)}
+				})
+		end,
+	    {ok,NewState} = Mod:surrendered(State,Synch,NewE),
+	    NewRole = case Role of
+			  waiting_worker ->
+			      worker;
+			  _ ->
+			      surrendered
+		      end,
+	    loop(Server#server{state = NewState}, NewRole, NewE);
+	{leader, local_only, Node, Candidate} ->
+	    case lists:keysearch(node(Candidate), 2, E#election.monitored) of
+		{value, {Ref, N}} ->
+		    NewE = down(Ref, {E#election.name,N},local_only,E),
+		    io:format("local_only received from ~p~n"
+			      "E0 = ~p~n"
+			      "E1 = ~p~n", [Node, E, NewE]),
+		    safe_after_down(Server, Role, NewE);
+		false ->
+		    safe_loop(Server, Role, E)
+	    end;
+	{'DOWN',Ref,process,{Name,_}=Who,Why} ->
+	    NewE = 
+		down(Ref,Who,Why,E),
+	    safe_after_down(Server, Role, NewE)
+    end.
+
+safe_after_down(Server, Role, E) ->
+    case {Role,E#election.leader} of
+	{candidate,_} ->
+	    check_majority(E, Server);
+	{captured,none} ->
+	    check_majority(broadcast(capture,E), Server);
+	{waiting_worker,_} ->
+	    safe_loop(Server, Role, E)
+    end.
+
+
+loop(#server{parent = Parent,
+	     mod = Mod,
+	     state = State,
+	     debug = Debug} = Server, Role,
+     #election{mode = Mode, name = Name} = E) ->
+    Msg = receive
+
+	      Input ->
+		    Input
+	  end,
+    case Msg of
+	{system, From, Req} ->
+	    sys:handle_system_msg(Req, From, Parent, ?MODULE, Debug,
+				  [normal, Server, Role, E]);
+	{'EXIT', Parent, Reason} ->
+	    terminate(Reason, Msg, Server, Role, E);
+	{leader, local_only, _, _Candidate} ->
+	    loop(Server, Role, E);
+	LeaderMsg when element(1,LeaderMsg) == leader, Mode == local ->
+	    Candidate = element(size(LeaderMsg), LeaderMsg),
+	    Candidate ! {leader, local_only, node(), self()},
+	    loop(Server, Role, E);
+	{leader,capture,_Iteration,_Node,Candidate} ->
+	    NewE = nodeup(node(Candidate),E),
+	    case Role of
+		R when R == surrendered; R == worker ->
+		    loop(Server, Role, NewE);
+		elected ->
+		    {ok,Synch,NewState} = Mod:elected(State,NewE),
+		    Candidate ! {leader, elect, Synch, self()},
+		    loop(Server#server{state = NewState}, Role, NewE)
+	    end;
+	{leader,accept,_Iteration,Candidate} ->
+	    NewE = nodeup(node(Candidate),E),
+	    case Role of
+		surrendered ->
+		    loop(Server, Role, NewE);
+		elected ->
+		    {ok,Synch,NewState} = Mod:elected(State,NewE),
+		    Candidate ! {leader, elect, Synch, self()},
+		    loop(Server#server{state = NewState}, Role, NewE)
+	    end;
+	{leader,elect,Synch,Candidate} ->
+	    NewE = 
+		case Role of
+		    worker ->
+			nodeup(node(Candidate),
+			       E#election{
+				 leader = Candidate,
+				 leadernode = node(Candidate)});
+		    surrendered ->
+			nodeup(node(Candidate),
+			       E#election{
+				 leader = Candidate,
+				 leadernode = node(Candidate),
+				 iteration = {[],
+					      position(
+						node(),
+						E#election.candidate_nodes)}
+				})
+		end,
+	    {ok, NewState} = Mod:surrendered(State, Synch, NewE),
+	    loop(Server#server{state = NewState}, Role, NewE);
+	{'DOWN',Ref,process,{Name,Node} = Who,Why} ->
+	    #election{alive = PreviouslyAlive} = E,
+	    NewE = 
+		down(Ref,Who,Why,E),
+	    case NewE#election.leader of
+		none ->
+		    foreach(fun({_,From}) ->
+				    reply(From,{error,leader_died})
+			    end, E#election.buffered),
+		    NewE1 = NewE#election{buffered = []},
+		    case Role of 
+			surrendered ->
+			    check_majority(
+			      broadcast(capture,NewE1), Server);
+			worker ->
+			    safe_loop(Server, waiting_worker, NewE1)
+		    end;
+		L when L == self() ->
+		    case member(Node, PreviouslyAlive) of
+			true ->
+			    case Mod:handle_DOWN(Node, State, E) of
+				{ok, NewState} ->
+				    loop(Server#server{state = NewState},
+					 Role, NewE);
+				{ok, Broadcast, NewState} ->
+				    NewE1 = broadcast(
+					      {from_leader,Broadcast}, NewE),
+				    loop(Server#server{state = NewState},
+					 Role, NewE1)
+			    end;
+			false ->
+			    loop(Server, Role, NewE)
+		    end;
+		_ ->
+		    loop(Server, Role, NewE)
+	    end;
+	_Msg when Debug == [] ->
+	    handle_msg(Msg, Server, Role, E);
+	_Msg ->
+	    Debug1 = sys:handle_debug(Debug, {?MODULE, print_event}, 
+				      E#election.name, {in, Msg}),
+	    handle_msg(Msg, Server#server{debug = Debug1}, Role, E)
+    end.
+
+%%-----------------------------------------------------------------
+%% Callback functions for system messages handling.
+%%-----------------------------------------------------------------
+
+%% @hidden
+system_continue(_Parent, Debug, [safe, Server, Role, E]) ->
+    safe_loop(Server#server{debug = Debug}, Role, E);
+system_continue(_Parent, Debug, [normal, Server, Role, E]) ->
+    loop(Server#server{debug = Debug}, Role, E).
+
+%% @hidden
+system_terminate(Reason, _Parent, Debug, [_Mode, Server, Role, E]) ->
+    terminate(Reason, [], Server#server{debug = Debug}, Role, E).
+
+%% @hidden
+system_code_change([Mode, Server, Role, E], _Module, OldVsn, Extra) ->
+    #server{mod = Mod, state = State} = Server,
+    case catch Mod:code_change(OldVsn, State, E, Extra) of
+	{ok, NewState} ->
+	    NewServer = Server#server{state = NewState},
+	    {ok, [Mode, NewServer, Role, E]};
+	{ok, NewState, NewE} ->
+	    NewServer = Server#server{state = NewState},
+	    {ok, [Mode, NewServer, Role, NewE]};
+	Else -> Else
+    end.
+
+%%-----------------------------------------------------------------
+%% Format debug messages.  Print them as the call-back module sees
+%% them, not as the real erlang messages.  Use trace for that.
+%%-----------------------------------------------------------------
+%% @hidden
+print_event(Dev, {in, Msg}, Name) ->
+    case Msg of
+	{'$gen_call', {From, _Tag}, Call} ->
+	    io:format(Dev, "*DBG* ~p got local call ~p from ~w~n",
+		      [Name, Call, From]);
+	{'$leader_call', {From, _Tag}, Call} ->
+	    io:format(Dev, "*DBG* ~p got global call ~p from ~w~n",
+		      [Name, Call, From]);
+	{'$gen_cast', Cast} ->
+	    io:format(Dev, "*DBG* ~p got local cast ~p~n",
+		      [Name, Cast]);
+	{'$leader_cast', Cast} ->
+	    io:format(Dev, "*DBG* ~p got global cast ~p~n",
+		      [Name, Cast]);
+	_ ->
+	    io:format(Dev, "*DBG* ~p got ~p~n", [Name, Msg])
+    end;
+print_event(Dev, {out, Msg, To, State}, Name) ->
+    io:format(Dev, "*DBG* ~p sent ~p to ~w, new state ~w~n", 
+	      [Name, Msg, To, State]);
+print_event(Dev, {noreply, State}, Name) ->
+    io:format(Dev, "*DBG* ~p new state ~w~n", [Name, State]);
+print_event(Dev, Event, Name) ->
+    io:format(Dev, "*DBG* ~p dbg  ~p~n", [Name, Event]).
+
+
+handle_msg({'$leader_call', From, Request} = Msg, 
+	   #server{mod = Mod, state = State} = Server, elected = Role, E) ->
+    case catch Mod:handle_leader_call(Request, From, State, E) of
+	{reply, Reply, NState} ->
+	    NewServer = reply(From, {leader,reply,Reply},
+			      Server#server{state = NState}, Role, E),
+	    loop(NewServer, Role, E);
+	{reply, Reply, Broadcast, NState} ->
+	    NewE = broadcast({from_leader,Broadcast}, E),
+	    NewServer = reply(From, {leader,reply,Reply},
+			      Server#server{state = NState}, Role,
+			      NewE),
+	    loop(NewServer, Role, NewE);
+	{noreply, NState} = Reply ->
+	    NewServer = handle_debug(Server#server{state = NState},
+				     Role, E, Reply),
+	    loop(NewServer, Role, E);
+	{stop, Reason, Reply, NState} ->
+	    {'EXIT', R} = 
+		(catch terminate(Reason, Msg, 
+				 Server#server{state = NState},
+				 Role, E)),
+	    reply(From, Reply),
+	    exit(R);
+	Other ->
+	    handle_common_reply(Other, Msg, Server, Role, E)
+    end;
+handle_msg({'$leader_call', From, Request} = Msg,
+	   #server{mod = Mod, state = State} = Server, Role,
+	   #election{mode = local} = E) ->
+    Reply = (catch Mod:handle_leader_call(Request,From,State,E)),
+    handle_call_reply(Reply, Msg, Server, Role, E);
+%%%    handle_common_reply(Reply, Msg, Server, Role, E);
+handle_msg({'$leader_cast', Cast} = Msg,
+	   #server{mod = Mod, state = State} = Server, Role,
+	   #election{mode = local} = E) ->
+    Reply = (catch Mod:handle_leader_cast(Cast,State,E)),
+    handle_common_reply(Reply, Msg, Server, Role, E);
+handle_msg({'$leader_cast', Cast} = Msg, 
+	   #server{mod = Mod, state = State} = Server, elected = Role, E) ->
+    Reply = (catch Mod:handle_leader_cast(Cast, State, E)),
+    handle_common_reply(Reply, Msg, Server, Role, E);
+handle_msg({from_leader, Cmd} = Msg, 
+	   #server{mod = Mod, state = State} = Server, Role, E) ->
+    handle_common_reply(catch Mod:from_leader(Cmd, State, E), 
+			Msg, Server, Role, E);
+handle_msg({'$leader_call', From, Request}, Server, Role,
+	   #election{buffered = Buffered, leader = Leader} = E) ->
+    Ref = make_ref(),
+    Leader ! {'$leader_call', {self(),Ref}, Request},
+    NewBuffered = [{Ref,From}|Buffered],
+    loop(Server, Role, E#election{buffered = NewBuffered});
+handle_msg({Ref, {leader,reply,Reply}}, Server, Role,
+	   #election{buffered = Buffered} = E) ->
+    {value, {_,From}} = keysearch(Ref,1,Buffered),
+    NewServer = reply(From, {leader,reply,Reply}, Server, Role,
+		      E#election{buffered = keydelete(Ref,1,Buffered)}),
+    loop(NewServer, Role, E);
+handle_msg({'$gen_call', From, Request} = Msg, 
+	   #server{mod = Mod, state = State} = Server, Role, E) ->
+    Reply = (catch Mod:handle_call(Request, From, State)),
+    handle_call_reply(Reply, Msg, Server, Role, E);
+handle_msg({'$gen_cast',Msg} = Cast,
+	   #server{mod = Mod, state = State} = Server, Role, E) ->
+    handle_common_reply(catch Mod:handle_cast(Msg, State), 
+			Cast, Server, Role, E);
+handle_msg(Msg,
+	   #server{mod = Mod, state = State} = Server, Role, E) ->
+    handle_common_reply(catch Mod:handle_info(Msg, State),
+			Msg, Server, Role, E).
+
+
+handle_call_reply(CB_reply, {_, From, _Request} = Msg, Server, Role, E) ->
+    case CB_reply of
+    	{reply, Reply, NState} ->
+	    NewServer = reply(From, Reply, 
+			      Server#server{state = NState}, Role, E),
+	    loop(NewServer, Role, E);
+	{noreply, NState} = Reply ->
+	    NewServer = handle_debug(Server#server{state = NState},
+				     Role, E, Reply),
+	    loop(NewServer, Role, E);
+	{activate, Cands, Workers, Reply, NState}
+	when E#election.mode == local ->
+	    NewRole = case member(node(), Cands) of
+			  true -> candidate;
+			  false -> waiting_worker
+		      end,
+	    reply(From, Reply),
+	    NServer = Server#server{state = NState},
+	    NewE = init_election(Cands, Workers, E),
+	    io:format("activating: NewE = ~p~n", [NewE]),
+	    begin_election(NServer, NewRole, NewE);
+	{stop, Reason, Reply, NState} ->
+	    {'EXIT', R} = 
+		(catch terminate(Reason, Msg, Server#server{state = NState},
+				 Role, E)),
+	    reply(From, Reply),
+	    exit(R);
+	Other ->
+	    handle_common_reply(Other, Msg, Server, Role, E)
+    end.
+
+
+handle_common_reply(Reply, Msg, Server, Role, E) ->
+    case Reply of
+	{ok, NState} ->
+	    NewServer = handle_debug(Server#server{state = NState},
+				     Role, E, Reply),
+	    loop(NewServer, Role, E);
+	{ok, Broadcast, NState} ->
+	    NewE = broadcast({from_leader,Broadcast}, E),
+	    NewServer = handle_debug(Server#server{state = NState},
+				     Role, E, Reply),
+	    loop(NewServer, Role, NewE);
+	{stop, Reason, NState} ->
+	    terminate(Reason, Msg, Server#server{state = NState}, Role, E);
+	{'EXIT', Reason} ->
+	    terminate(Reason, Msg, Server, Role, E);
+	_ ->
+	    terminate({bad_return_value, Reply}, Msg, Server, Role, E)
+    end.
+
+
+reply({To, Tag}, Reply, #server{state = State} = Server, Role, E) ->
+    reply({To, Tag}, Reply),
+    handle_debug(Server, Role, E, {out, Reply, To, State}).
+
+
+handle_debug(#server{debug = []} = Server, _Role, _E, _Event) ->
+    Server;
+handle_debug(#server{debug = Debug} = Server, _Role, E, Event) ->
+    Debug1 = sys:handle_debug(Debug, {?MODULE, print_event}, 
+			      E#election.name, Event),
+    Server#server{debug = Debug1}.
+
+%%% ---------------------------------------------------
+%%% Terminate the server.
+%%% ---------------------------------------------------
+
+terminate(Reason, Msg, #server{mod = Mod, 
+			       state = State,
+			       debug = Debug}, _Role,
+	  #election{name = Name}) ->
+    case catch Mod:terminate(Reason, State) of
+	{'EXIT', R} ->
+	    error_info(R, Name, Msg, State, Debug),
+	    exit(R);
+	_ ->
+	    case Reason of
+		normal ->
+		    exit(normal);
+		shutdown ->
+		    exit(shutdown);
+		_ ->
+		    error_info(Reason, Name, Msg, State, Debug),
+		    exit(Reason)
+	    end
+    end.
+
+%% Maybe we shouldn't do this?  We have the crash report...
+error_info(Reason, Name, Msg, State, Debug) ->
+    format("** Generic leader ~p terminating \n"
+           "** Last message in was ~p~n"
+           "** When Server state == ~p~n"
+           "** Reason for termination == ~n** ~p~n",
+	   [Name, Msg, State, Reason]),
+    sys:print_log(Debug),
+    ok.
+
+%%% ---------------------------------------------------
+%%% Misc. functions.
+%%% ---------------------------------------------------
+
+opt(Op, [{Op, Value}|_]) ->
+    {ok, Value};
+opt(Op, [_|Options]) ->
+    opt(Op, Options);
+opt(_, []) ->
+    false.
+
+debug_options(Name, Opts) ->
+    case opt(debug, Opts) of
+	{ok, Options} -> dbg_options(Name, Options);
+	_ -> dbg_options(Name, [])
+    end.
+
+dbg_options(Name, []) ->
+    Opts = 
+	case init:get_argument(generic_debug) of
+	    error ->
+		[];
+	    _ ->
+		[log, statistics]
+	end,
+    dbg_opts(Name, Opts);
+dbg_options(Name, Opts) ->
+    dbg_opts(Name, Opts).
+
+dbg_opts(Name, Opts) ->
+    case catch sys:debug_options(Opts) of
+	{'EXIT',_} ->
+	    format("~p: ignoring erroneous debug options - ~p~n",
+		   [Name, Opts]),
+	    [];
+	Dbg ->
+	    Dbg
+    end.
+
+%%-----------------------------------------------------------------
+%% Status information
+%%-----------------------------------------------------------------
+%% @hidden
+format_status(Opt, StatusData) ->
+    [PDict, SysState, Parent, Debug, [_Mode, Server, _Role, E]] = StatusData,
+    Header = lists:concat(["Status for generic server ", E#election.name]),
+    Log = sys:get_debug(log, Debug, []),
+    #server{mod = Mod, state = State} = Server,
+    Specific = 
+	case erlang:function_exported(Mod, format_status, 2) of
+	    true ->
+		case catch apply(Mod, format_status, [Opt, [PDict, State]]) of
+		    {'EXIT', _} -> [{data, [{"State", State}]}];
+		    Else -> Else
+		end;
+	    _ ->
+		[{data, [{"State", State}]}]
+	end,
+    [{header, Header},
+     {data, [{"Status", SysState},
+	     {"Parent", Parent},
+	     {"Logged events", Log}]} |
+     Specific].
+
+
+
+
+broadcast(Msg, #election{monitored = Monitored} = E) ->
+    %% When broadcasting the first time, we broadcast to all candidate nodes,
+    %% using broadcast/3. This function is used for subsequent broadcasts,
+    %% and we make sure only to broadcast to already known nodes.
+    %% It's the responsibility of new nodes to make themselves known through
+    %% a wider broadcast.
+    ToNodes = [N || {_,N} <- Monitored],
+    broadcast(Msg, ToNodes, E).
+
+broadcast(capture, ToNodes, #election{monitored = Monitored} = E) ->
+    ToMonitor = [N || N <- ToNodes,
+                      not(keymember(N,2,Monitored))],
+    NewE = 
+        foldl(fun(Node,Ex) ->
+                      Ref = erlang:monitor(
+			      process,{Ex#election.name,Node}),
+                      Ex#election{monitored = [{Ref,Node}|
+					      Ex#election.monitored]}
+              end,E,ToMonitor),
+    foreach(
+      fun(Node) ->
+	      {NewE#election.name,Node} !
+		  {leader,capture,NewE#election.iteration,node(),self()}
+      end,ToNodes),
+    NewE;
+broadcast({elect,Synch},ToNodes,E) ->
+    foreach(
+      fun(Node) ->
+	      {E#election.name,Node} ! {leader,elect,Synch,self()}
+      end,ToNodes),
+    E;
+broadcast({from_leader, Msg}, ToNodes, E) ->
+    foreach(
+      fun(Node) ->
+	      {E#election.name,Node} ! {from_leader, Msg}
+      end,ToNodes),
+    E;
+broadcast(add_worker, ToNodes, E) ->
+    foreach(
+      fun(Node) ->
+	      {E#election.name,Node} ! {leader, add_worker, self()}
+      end,ToNodes),
+    E.
+
+
+
+check_majority(E, Server) ->
+    {Captured,_} = E#election.iteration,
+    AcceptMeAsLeader = length(Captured) + 1,   % including myself
+    NrCandidates = length(E#election.candidate_nodes),
+    NrDown = E#election.down,
+    if AcceptMeAsLeader > NrCandidates/2 ->
+	    NewE = E#election{leader = self(), leadernode = node()},
+	    {ok,Synch,NewState} =
+		(Server#server.mod):elected(Server#server.state, NewE),
+	    NewE1 = broadcast({elect,Synch}, NewE),
+	    loop(Server#server{state = NewState}, elected, NewE1);
+       AcceptMeAsLeader+length(NrDown) == NrCandidates -> 
+	    NewE = E#election{leader = self(), leadernode = node()},
+	    {ok,Synch,NewState} =
+		(Server#server.mod):elected(Server#server.state, NewE),
+	    NewE1 = broadcast({elect,Synch}, NewE),
+	    loop(Server#server{state = NewState}, elected, NewE1);
+       true ->
+	    safe_loop(Server, candidate, E)
+    end.
+
+
+down(Ref,_Who,Why,E) ->
+    case lists:keysearch(Ref,1,E#election.monitored) of
+	{value, {_,Node}} ->
+	    NewMonitored = if Why == local_only -> E#election.monitored;
+			      true ->
+				   E#election.monitored -- [{Ref,Node}]
+			   end,
+	    {Captured,Pos} = E#election.iteration,
+	    case Node == E#election.leadernode of
+		true ->
+		    E#election{leader = none,
+			       leadernode = none,
+			       iteration = {Captured -- [Node],
+					    Pos},  % TAKE CARE !
+			       down = [Node|E#election.down],
+			       alive = E#election.alive -- [Node],
+			       monitored = NewMonitored};
+		false ->
+		    Down = case member(Node,E#election.candidate_nodes) of
+			       true ->
+				   [Node|E#election.down];
+			       false ->
+				   E#election.down
+			   end,
+		    E#election{iteration = {Captured -- [Node],
+					    Pos},  % TAKE CARE !
+			       down = Down,
+			       alive = E#election.alive -- [Node],
+			       monitored = NewMonitored}
+	    end
+    end.
+
+
+
+%% position of element counted from end of the list
+%%
+position(X,[Head|Tail]) ->
+    case X==Head of
+        true ->
+            length(Tail);
+        false ->
+            position(X,Tail)
+    end.
+
+%% This is a multi-level comment
+%% This is the second line of the comment
+lexcompare({C1,P1},{C2,P2}) ->
+    lexcompare([{length(C1),length(C2)},{P1,P2}]).
+
+lexcompare([]) ->
+    equal;
+lexcompare([{X,Y}|Rest]) ->
+    if X<Y  -> less;
+       X==Y -> lexcompare(Rest);
+       X>Y  -> greater
+    end.
+
+add_captured({Captured,Pos}, CandidateNode) ->
+    {[CandidateNode|[ Node || Node <- Captured,
+			      Node =/= CandidateNode ]], Pos}.
+
+nodeup(Node, #election{monitored = Monitored,
+		       alive = Alive,
+		       down = Down} = E) ->
+    %% make sure process is monitored from now on
+    case [ N || {_,N}<-Monitored, N==Node] of
+        [] ->
+            Ref = erlang:monitor(process,{E#election.name,Node}),
+            E#election{down = Down -- [Node],
+		       alive = [Node | Alive],
+		       monitored = [{Ref,Node}|Monitored]};
+        _ ->    % already monitored, thus not in down
+            E#election{alive = [Node | [N || N <- Alive,
+					     N =/= Node]]}
+    end.
+
diff --git a/lib/kernel/src/gproc.erl b/lib/kernel/src/gproc.erl
new file mode 100644
index 0000000..eb539b9
--- /dev/null
+++ lib/kernel/src/gproc.erl
@@ -0,0 +1,974 @@
+-module(gproc).
+-behaviour(gen_leader).
+
+-export([start_link/0, start_link/1,
+	 reg/2, unreg/1,
+	 mreg/3,
+	 set_value/2,
+	 get_value/1,
+	 update_counter/2,
+	 send/2,
+	 info/1, info/2,
+	 select/1, select/2,
+	 first/1,
+	 next/2,
+	 prev/2,
+	 last/1,
+	 table/1, table/2]).
+
+-export([start_local/0, go_global/0, go_global/1]).
+
+%%% internal exports
+-export([init/1,
+	 handle_cast/2,
+	 handle_call/3,
+	 handle_info/2,
+	 handle_leader_call/4,
+	 handle_leader_cast/3,
+	 handle_DOWN/3,
+	 elected/2,
+	 surrendered/3,
+	 from_leader/3,
+	 code_change/4,
+	 terminate/2]).
+
+-define(TAB, ?MODULE).
+-define(SERVER, ?MODULE).
+
+-record(state, {mode, is_leader}).
+
+start_local() ->
+    create_tabs(),
+    gen_leader:start(?SERVER, ?MODULE, [], []).
+
+go_global() ->
+    erlang:display({"calling go_global (Ns = ~p)~n", [node()|nodes()]}),
+    go_global([node()|nodes()]).
+
+go_global(Nodes) when is_list(Nodes) ->
+    erlang:display({"calling go_global(~p)~n", [node()|nodes()]}),
+    case whereis(?SERVER) of
+	undefined ->
+	    start_link(Nodes);
+	Pid ->
+	    link(Pid),
+	    ok = call({go_global, Nodes}),
+	    {ok, Pid}
+    end.
+
+start_link() ->
+    start_link([node()|nodes()]).
+
+start_link(Nodes) ->
+    create_tabs(),
+    gen_leader:start_link(
+      ?SERVER, Nodes, [],?MODULE, [], [{debug,[trace]}]).
+
+%%% @spec({Class,Scope, Key}, Value) -> true
+%%% @doc
+%%%    Class = n  - unique name
+%%%          | p  - non-unique property
+%%%          | c  - counter
+%%%          | a  - aggregated counter
+%%%    Scope = l | g (global or local)
+%%%
+reg({_,g,_} = Key, Value) ->
+    %% anything global
+    leader_call({reg, Key, Value, self()});
+reg({T,l,_} = Key, Value) when T==n; T==a ->
+    %% local names and aggregated counters
+    call({reg, Key, Value});
+reg({c,l,_} = Key, Value) ->
+    %% local counter
+    if is_integer(Value) ->
+	    local_reg(Key, Value);
+       true ->
+	    erlang:error(badarg)
+    end;
+reg({_,l,_} = Key, Value) ->
+    %% local property
+    local_reg(Key, Value);
+reg(_, _) ->
+    erlang:error(badarg).
+
+mreg(T, g, KVL) ->
+    if is_list(KVL) -> leader_call({mreg, T, g, KVL, self()});
+       true -> erlang:error(badarg)
+    end;
+mreg(T, l, KVL) when T==a; T==n ->
+    if is_list(KVL) -> call({mreg, T, l, KVL});
+       true -> erlang:error(badarg)
+    end;
+mreg(p, l, KVL) ->
+    local_mreg(p, KVL);
+mreg(_, _, _) ->
+    erlang:error(badarg).
+
+unreg(Key) ->
+    case Key of
+	{_, g, _} -> leader_call({unreg, Key, self()});
+	{T, l, _} when T == n;
+		       T == a -> call({unreg, Key});
+	{_, l, _} ->
+	    case ets:member(?TAB, {Key,self()}) of
+		true ->
+		    remove_reg(Key, self());
+		false ->
+		    erlang:error(badarg)
+	    end
+    end.
+
+select(Pat) ->
+    select(all, Pat).
+
+select(Scope, Pat) ->
+    ets:select(?TAB, pattern(Pat, Scope)).
+
+select(Scope, Pat, NObjs) ->
+    ets:select(?TAB, pattern(Pat, Scope), NObjs).
+
+
+%%% Local properties can be registered in the local process, since
+%%% no other process can interfere.
+%%%
+local_reg(Key, Value) ->
+    case insert_reg(Key, Value, self(), l) of
+	false -> erlang:error(badarg);
+	true  -> monitor_me()
+    end.
+
+local_mreg(_, []) -> true;
+local_mreg(T, [_|_] = KVL) ->
+    case insert_many(T, l, KVL, self()) of
+	false     -> erlang:error(badarg);
+	{true,_}  -> monitor_me()
+    end.
+
+
+
+remove_reg({c,_,_} = Key, Pid) ->
+    remove_counter(Key, ets:lookup_element(?TAB, {Key,Pid}, 3), Pid);
+remove_reg({T,_,_} = Key, Pid) when T==a; T==n ->
+    ets:delete(?TAB, {Key,T}),
+    ets:delete(?TAB, {Pid,Key});
+remove_reg({_,_,_} = Key, Pid) ->
+    ets:delete(?TAB, {Key, Pid}),
+    ets:delete(?TAB, {Pid, Key}).
+    
+remove_counter({c,C,N} = Key, Val, Pid) ->
+    update_aggr_counter(C, N, -Val),
+    ets:delete(?TAB, {Key, Pid}),
+    ets:delete(?TAB, {Pid, Key}).
+
+
+insert_reg({T,_,Name} = K, Value, Pid, C) when T==a; T==n ->
+    %%% We want to store names and aggregated counters with the same
+    %%% structure as properties, but at the same time, we must ensure
+    %%% that the key is unique. We replace the Pid in the key part with
+    %%% an atom. To know which Pid owns the object, we lug the Pid around
+    %%% as payload as well. This is a bit redundant, but symmetric.
+    %%%
+    case ets:insert_new(?TAB, [{{K, T}, Pid, Value}, {{Pid,K}}]) of
+	true ->
+	    if T == a ->
+		    Initial = scan_existing_counters(C, Name),
+		    ets:insert(?TAB, {{K,a}, Pid, Initial});
+	       T == c ->
+		    update_aggr_counter(l, Name, Value);
+	       true ->
+		    true
+	    end,
+	    true;
+	false ->
+	    false
+    end;
+insert_reg(Key, Value, Pid, _C) ->
+    %% Non-unique keys; store Pid in the key part
+    K = {Key, Pid},
+    Kr = {Pid, Key},
+    ets:insert_new(?TAB, [{K, Pid, Value}, {Kr}]).
+
+insert_many(T, C, KVL, Pid) ->
+    Objs = mk_reg_objs(T, C, Pid, KVL),
+    case ets:insert_new(?TAB, Objs) of
+	true ->
+	    RevObjs = mk_reg_rev_objs(T, C, Pid, KVL),
+	    ets:insert(?TAB, RevObjs),
+	    {true, Objs};
+	false ->
+	    false
+    end.
+
+mk_reg_objs(T, C, _, L) when T == n; T == a ->
+    lists:map(fun({K,V}) ->
+		      {{{T,C,K},T}, V};
+		 (_) ->
+		      erlang:error(badarg)
+	      end, L);
+mk_reg_objs(p = T, C, Pid, L) ->
+    lists:map(fun({K,V}) ->
+		      {{{T,C,K},Pid}, V};
+		 (_) ->
+		      erlang:error(badarg)
+	      end, L).
+
+mk_reg_rev_objs(T, C, Pid, L) ->
+    [{Pid,{T,C,K}} || {K,_} <- L].
+			  
+
+set_value({T,g,_} = Key, Value) when T==a; T==c ->
+    if is_integer(Value) ->
+	    leader_call({set, Key, Value});
+       true ->
+	    erlang:error(badarg)
+    end;
+set_value({_,g,_} = Key, Value) ->
+    leader_call({set, Key, Value, self()});
+set_value({a,l,_} = Key, Value) when is_integer(Value) ->
+    call({set, Key, Value});
+set_value({n,l,_} = Key, Value) ->
+    %% we cannot do this locally, since we have to check that the object
+    %% exists first - not an atomic update.
+    call({set, Key, Value});
+set_value({p,l,_} = Key, Value) ->
+    %% we _can_ to this locally, since there is no race condition - no
+    %% other process can update our properties.
+    case do_set_value(Key, Value, self()) of
+	true -> true;
+	false ->
+	    erlang:error(badarg)
+    end;
+set_value({c,l,_} = Key, Value) when is_integer(Value) ->
+    do_set_counter_value(Key, Value, self());
+set_value(_, _) ->
+    erlang:error(badarg).
+
+
+do_set_value({T,_,_} = Key, Value, Pid) ->
+    K2 = if T==n -> T;
+	    true -> Pid
+	 end,
+    case ets:member(?TAB, {Key, K2}) of
+	true ->
+	    ets:insert(?TAB, {{Key, K2}, Pid, Value});
+	false ->
+	    false
+    end.
+
+do_set_counter_value({_,C,N} = Key, Value, Pid) ->
+    OldVal = ets:lookup_element(?TAB, {Key, Pid}, 3), % may fail with badarg
+    update_aggr_counter(C, N, Value - OldVal),
+    ets:insert(?TAB, {{Key, Pid}, Pid, Value}).
+
+
+
+
+%%% @spec (Key) -> Value
+%%% @doc Read the value stored with a key registered to the current process.
+%%%
+get_value(Key) ->
+    get_value(Key, self()).
+
+get_value({T,_,_} = Key, Pid) when is_pid(Pid) ->
+    if T==n; T==a ->
+	    case ets:lookup(?TAB, {Key, T}) of
+		[{_, P, Value}] when P == Pid -> Value;
+		_ -> erlang:error(badarg)
+	    end;
+       true ->
+	    ets:lookup_element(?TAB, {Key, Pid}, 3)
+    end;
+get_value(_, _) ->
+    erlang:error(badarg).
+
+
+update_counter({c,l,Ctr} = Key, Incr) when is_integer(Incr) ->
+    update_aggr_counter(l, Ctr, Incr),
+    ets:update_counter(?TAB, Key, {3,Incr});
+update_counter({c,g,_} = Key, Incr) when is_integer(Incr) ->
+    leader_call({update_counter, Key, Incr, self()});
+update_counter(_, _) ->
+    erlang:error(badarg).
+
+
+update_aggr_counter(C, N, Val) ->
+    catch ets:update_counter(?TAB, {{a,C,N},a}, {3, Val}).
+
+
+
+send({T,C,_} = Key, Msg) when C==l; C==g ->
+    if T == n; T == a ->
+	    case ets:lookup(?TAB, {Key, T}) of
+		[{_, Pid, _}] ->
+		    Pid ! Msg;
+		[] ->
+		    erlang:error(badarg)
+	    end;
+       T==p; T==c ->
+	    %% BUG - if the key part contains select wildcards, we may end up
+	    %% sending multiple messages to the same pid
+	    Head = {{Key,'$1'},'_'},
+	    Pids = ets:select(?TAB, [{Head,[],['$1']}]),
+	    lists:foreach(fun(Pid) ->
+				  Pid ! Msg
+			  end, Pids),
+	    Msg;
+       true ->
+	    erlang:error(badarg)
+    end;
+send(_, _) ->
+    erlang:error(badarg).
+    
+
+first(Scope) ->
+    {HeadPat,_} = headpat(Scope, '_', '_', '_'),
+    case ets:select(?TAB, [{HeadPat,[],[{element,1,'$_'}]}], 1) of
+	{[First], _} ->
+	    First;
+	_ ->
+	    '$end_of_table'
+    end.
+
+last(Scope) ->
+    {C, T} = get_c_t(Scope),
+    C1 = if C == '_'; C == l -> m;
+	    C == g -> h
+	 end,
+    Beyond = {{T,C1,[]},[]},
+    step(ets:prev(?TAB, Beyond), C, T).
+
+next(Scope, K) ->
+    {C,T} = get_c_t(Scope),
+    step(ets:next(?TAB,K), C, T).
+
+prev(Scope, K) ->
+    {C, T} = get_c_t(Scope),
+    step(ets:prev(?TAB, K), C, T).
+
+step(Key, '_', '_') ->
+    case Key of
+	{{_,_,_},_} -> Key;
+	_ -> '$end_of_table'
+    end;
+step(Key, '_', T) ->
+    case Key of
+	{{T,_,_},_} -> Key;
+	_ -> '$end_of_table'
+    end;
+step(Key, C, '_') ->
+    case Key of
+	{{_, C, _}, _} -> Key;
+	_ -> '$end_of_table'
+    end;
+step(Key, C, T) ->
+    case Key of
+	{{T,C,_},_} -> Key;
+	_ -> '$end_of_table'
+    end.
+
+
+
+info(Pid) when is_pid(Pid) ->
+    Items = [?MODULE | [ I || {I,_} <- process_info(self())]],
+    [info(Pid,I) || I <- Items].
+
+info(Pid, ?MODULE) ->
+    Keys = ets:select(?TAB, [{ {{Pid,'$1'}}, [], ['$1'] }]),
+    {?MODULE, lists:zf(
+		fun(K) ->
+			try V = get_value(K, Pid),
+			    {true, {K,V}}
+			catch
+			    error:_ ->
+				false
+			end
+		end, Keys)};
+info(Pid, I) ->
+    process_info(Pid, I).
+
+	     
+
+
+%%% ==========================================================
+
+
+handle_cast({monitor_me, Pid}, S) ->
+    erlang:monitor(process, Pid),
+    {ok, S}.
+
+handle_call({go_global, Nodes}, _, S) ->
+    erlang:display({"got go_global (~p)~n", [Nodes]}),
+    case S#state.mode of
+	local ->
+	    {activate, Nodes, [], ok, S#state{mode = global}};
+	global ->
+	    {reply, badarg, S}
+    end;
+handle_call({reg, {_,l,_} = Key, Val}, {Pid,_}, S) ->
+    case insert_reg(Key, Val, Pid, l) of
+	false ->
+	    {reply, badarg, S};
+	true ->
+	    ensure_monitor(Pid),
+	    {reply, true, S}
+    end;
+handle_call({unreg, {_,l,_} = Key}, {Pid,_}, S) ->
+    case ets:member(?TAB, {Pid,Key}) of
+	true ->
+	    remove_reg(Key, Pid),
+	    {reply, true, S};
+	false ->
+	    {reply, badarg, S}
+    end;
+handle_call({mreg, T, l, L}, {Pid,_}, S) ->
+    try	insert_many(T, l, L, Pid) of
+	{true,_} -> {reply, true, S};
+	false    -> {reply, badarg, S}
+    catch
+	error:_  -> {reply, badarg, S}
+    end;
+handle_call({set, {_,l,_} = Key, Value}, {Pid,_}, S) ->
+    case do_set_value(Key, Value, Pid) of
+	true ->
+	    {reply, true, S};
+	false ->
+	    {reply, badarg, S}
+    end;
+handle_call(_, _, S) ->
+    {reply, badarg, S}.
+
+handle_info({'DOWN', _MRef, process, Pid, _}, S) ->
+    Keys = ets:select(?TAB, [{{{Pid,'$1'}}, [], ['$1']}]),
+    case lists:keymember(g, 2, Keys) of
+	true ->
+	    leader_cast({pid_is_DOWN, Pid});
+	false ->
+	    ok
+    end,
+    ets:select_delete(?TAB, [{{{Pid,'_'}}, [], [true]}]),
+    ets:delete(?TAB, {Pid}),
+    lists:foreach(
+	  fun({T,C,N} = Key) ->
+		  if T == c ->
+			  Val = ets:lookup_element(?TAB, {Key,Pid}, 3),
+			  %% BUG - if wer're leader, this won't work
+			  update_aggr_counter(C,N, -Val);
+		     true -> ok
+		  end,
+		  ets:delete(?TAB, {Key,Pid})
+	  end, Keys),
+    {ok, S};
+handle_info(_, S) ->
+    {ok, S}.
+
+
+elected(S, _E) ->
+    Globs = ets:select(?TAB, [{{{{'_',g,'_'},'_'},'_','_'},[],['$_']}]),
+    {ok, {globals, Globs}, S#state{is_leader = true}}.
+
+surrendered(S, {globals, Globs}, _E) ->
+    %% globals from this node should be more correct in our table than
+    %% in the leader's
+    surrendered_1(Globs),
+    {ok, S#state{is_leader = false}}.
+
+
+handle_DOWN(Node, S, _E) ->
+    Head = {{{'_',g,'_'},'_'},'$1','_'},
+    Gs = [{'==', {node,'$1'},Node}],
+    Globs = ets:select(?TAB, [{Head, Gs, [{element,1,'$_'}]}]),
+    ets:select_delete(?TAB, [{Head, Gs, [true]}]),
+    {ok, [{delete, Globs}], S}.
+
+handle_leader_call(_, _, #state{mode = local} = S, _) ->
+    {reply, badarg, S};
+handle_leader_call({reg, {C,g,Name} = K, Value, Pid}, _From, S, _E) ->
+    case insert_reg(K, Value, Pid, g) of
+	false ->
+	    {reply, badarg, S};
+	true ->
+	    ensure_monitor(Pid),
+	    Vals =
+		if C == a ->
+			ets:lookup(?TAB, {K,a});
+		   C == c ->
+			case ets:lookup(?TAB, {{a,g,Name},a}) of
+			    [] ->
+				ets:lookup(?TAB, {K,Pid});
+			    [AC] ->
+				[AC | ets:lookup(?TAB, {K,Pid})]
+			end;
+		   C == n ->
+			[{{K,n},Pid,Value}];
+		   true ->
+			[{{K,Pid},Pid,Value}]
+		end,
+	    {reply, true, [{insert, Vals}], S}
+    end;
+handle_leader_call({unreg, {T,g,Name} = K, Pid}, _From, S, _E) ->
+    Key = if T == n; T == a -> {K,T};
+	     true -> {K, Pid}
+	  end,
+    case ets:member(?TAB, Key) of
+	true ->
+	    remove_reg(K, Pid),
+	    if T == c ->
+		    case ets:lookup(?TAB, {{a,g,Name},a}) of
+			[Aggr] ->
+			    %% updated by remove_reg/2
+			    {reply, true, [{delete,[{Key,Pid}]},
+					   {insert, [Aggr]}], S};
+			[] ->
+			    {reply, true, [{delete, [{Key, Pid}]}], S}
+		    end;
+	       true ->
+		    {reply, true, [{delete, [{Key,Pid}]}], S}
+	    end;
+	false ->
+	    {reply, badarg, S}
+    end;
+handle_leader_call({mreg, T, g, L, Pid}, _From, S, _E) ->
+    if T==p; T==n ->
+	    try insert_many(T, g, Pid, L) of
+		{true,Objs} -> {reply, true, [{insert,Objs}], S};
+		false       -> {reply, badarg, S}
+	    catch
+		error:_     -> {reply, badarg, S}
+	    end;
+       true -> {reply, badarg, S}
+    end;
+handle_leader_call({set,{T,g,N} =K,V,Pid}, _From, S, _E) ->
+    if T == a ->
+	    if is_integer(V) ->
+		    case do_set_value(K, V, Pid) of
+			true  -> {reply, true, [{insert,[{{K,T},Pid,V}]}], S};
+			false -> {reply, badarg, S}
+		    end
+	    end;
+       T == c ->
+	    try do_set_counter_value(K, V, Pid),
+		AKey = {{a,g,N},a},
+		Aggr = ets:lookup(?TAB, AKey),  % may be []
+		{reply, true, [{insert, [{{K,Pid},Pid,V} | Aggr]}], S}
+	    catch
+		error:_ ->
+		    {reply, badarg, S}
+	    end;
+       true ->
+	    case do_set_value(K, V, Pid) of
+		true ->
+		    Obj = if T==n -> {{K, T}, Pid, V};
+			     true -> {{K, Pid}, Pid, V}
+			  end,
+		    {reply, true, [{insert,[Obj]}], S};
+		false ->
+		    {reply, badarg, S}
+	    end
+    end;
+handle_leader_call(_, _, S, _E) ->
+    {reply, badarg, S}.
+
+handle_leader_cast(_, #state{mode = local} = S, _E) ->
+    {ok, S};
+handle_leader_cast({add_globals, Missing}, S, _E) ->
+    %% This is an audit message: a peer (non-leader) had info about granted
+    %% global resources that we didn't know of when we became leader.
+    %% This could happen due to a race condition when the old leader died.
+    ets:insert(?TAB, Missing),
+    {ok, [{insert, Missing}], S};
+handle_leader_cast({remove_globals, Globals}, S, _E) ->
+    delete_globals(Globals),
+    {ok, S};
+handle_leader_cast({pid_is_DOWN, Pid}, S, _E) ->
+    Keys = ets:select(?TAB, [{{{Pid,'$1'}},[],['$1']}]),
+    Globals = if node(Pid) =/= node() ->
+		      Keys;
+		 true ->
+		      [K || K <- Keys, element(2,K) == g]
+	      end,
+    ets:select_delete(?TAB, [{{{Pid,'_'}},[],[true]}]),
+    ets:delete(?TAB, Pid),
+    Modified = 
+	lists:foldl(
+	  fun({T,_,_}=K,A) when T==a;T==n -> ets:delete(?TAB, {K,T}), A;
+	     ({c,_,_}=K,A) -> cleanup_counter(K, Pid, A);
+	     (K,A) -> ets:delete(?TAB, {K,Pid}), A
+	  end, [], Keys),
+    case [{Op,Objs} || {Op,Objs} <- [{insert,Modified},
+				     {remove,Globals}], Objs =/= []] of
+	[] ->
+	    {ok, S};
+	Broadcast ->
+	    {ok, Broadcast, S}
+    end.
+
+code_change(_FromVsn, S, _Extra, _E) ->
+    {ok, S}.
+
+terminate(_Reason, _S) ->
+    ok.
+
+
+
+
+cleanup_counter({c,g,N}=K, Pid, Acc) ->
+    remove_reg(K,Pid),
+    case ets:lookup(?TAB, {{a,g,N},a}) of
+	[Aggr] ->
+	    [Aggr|Acc];
+	[] ->
+	    Acc
+    end;
+cleanup_counter(K, Pid, Acc) ->
+    remove_reg(K,Pid),
+    Acc.
+
+from_leader(Ops, S, _E) ->
+    lists:foreach(
+      fun({delete, Globals}) ->
+	      delete_globals(Globals);
+	 ({insert, Globals}) ->
+	      ets:insert(?TAB, Globals),
+	      lists:foreach(
+		fun({{{_,g,_}=Key,_}, P, _}) ->
+			ets:insert(?TAB, {{P,Key}}),
+			ensure_monitor(P)
+		end, Globals)
+      end, Ops),
+    {ok, S}.
+
+delete_globals(Globals) ->
+    lists:foreach(
+      fun({{Key,_}=K, Pid}) ->
+	      ets:delete(?TAB, K),
+	      ets:delete(?TAB, {{Pid, Key}})
+      end, Globals).
+    
+
+
+call(Req) ->
+    case gen_leader:call(?MODULE, Req) of
+	badarg -> erlang:error(badarg, Req);
+	Reply  -> Reply
+    end.
+
+cast(Msg) ->
+    gen_leader:cast(?MODULE, Msg).
+
+leader_call(Req) ->
+    case gen_leader:leader_call(?MODULE, Req) of
+	badarg -> erlang:error(badarg, Req);
+	Reply  -> Reply
+    end.
+
+leader_cast(Msg) ->
+    gen_leader:leader_cast(?MODULE, Msg).
+	     
+
+
+create_tabs() ->
+    ets:new(?MODULE, [ordered_set, public, named_table]).
+
+init({local_only,[]}) ->
+    {ok, #state{mode = local}};
+init([]) ->
+    {ok, #state{mode = global}}.
+
+
+surrendered_1(Globs) ->
+    My_local_globs =
+	ets:select(?TAB, [{{{{'_',g,'_'},'_'},'$1', '_'},
+			   [{'==', {node,'$1'}, node()}],
+			   ['$_']}]),
+    %% remove all remote globals - we don't have monitors on them.
+    ets:select_delete(?TAB, [{{{{'_',g,'_'},'_'}, '$1', '_'},
+			      [{'=/=', {node,'$1'}, node()}],
+			      [true]}]),
+    %% insert new non-local globals, collect the leader's version of
+    %% what my globals are
+    Ldr_local_globs =
+	lists:foldl(
+	  fun({{Key,_}=K, Pid, V}, Acc) when node(Pid) =/= node() ->
+		  ets:insert(?TAB, [{K, Pid, V}, {{Pid,Key}}]),
+		  Acc;
+	     ({_, Pid, _} = Obj, Acc) when node(Pid) == node() ->
+		  [Obj|Acc]
+	  end, [], Globs),
+    case [{K,P,V} || {K,P,V} <- My_local_globs,
+		   not(lists:keymember(K, 1, Ldr_local_globs))] of
+	[] ->
+	    %% phew! We have the same picture
+	    ok;
+	[_|_] = Missing ->
+	    %% This is very unlikely, I think
+	    leader_cast({add_globals, Missing})
+    end,
+    case [{K,P} || {K,P,_} <- Ldr_local_globs,
+		   not(lists:keymember(K, 1, My_local_globs))] of
+	[] ->
+	    ok;
+	[_|_] = Remove ->
+	    leader_cast({remove_globals, Remove})
+    end.
+
+
+ensure_monitor(Pid) when node(Pid) == node() ->
+    case ets:insert_new(?TAB, {Pid}) of
+	false -> ok;
+	true  -> erlang:monitor(process, Pid)
+    end;
+ensure_monitor(_) ->
+    true.
+
+monitor_me() ->
+    case ets:insert_new(?TAB, {self()}) of
+	false -> true;
+	true  ->
+	    cast({monitor_me,self()}),
+	    true
+    end.
+
+
+scan_existing_counters(Ctxt, Name) ->
+    Head = {{{c,Ctxt,Name},'_'},'_','$1'},
+    Cs = ets:select(?TAB, [{Head, [], ['$1']}]),
+    lists:sum(Cs).
+
+
+
+pattern([{'_', Gs, As}], T) ->
+    {HeadPat, Vs} = headpat(T, '$1', '$2', '$3'),
+    [{HeadPat, rewrite(Gs,Vs), rewrite(As,Vs)}];
+pattern([{{A,B,C},Gs,As}], Scope) ->
+    {HeadPat, Vars} = headpat(Scope, A,B,C),
+    [{HeadPat, rewrite(Gs,Vars), rewrite(As,Vars)}];
+pattern([{Head, Gs, As}], Scope) ->
+    case is_var(Head) of
+	{true,N} ->
+	    {A,B,C} = vars(N),
+	    {HeadPat, Vs} = headpat(Scope, A,B,C),
+	    %% the headpat function should somehow verify that Head is
+	    %% consistent with Scope (or should we add a guard?)
+	    [{HeadPat, rewrite(Gs, Vs), rewrite(As, Vs)}];
+	false ->
+	    erlang:error(badarg)
+    end.
+
+headpat({C, T}, V1,V2,V3) when C==global; C==local; C==all ->
+    headpat(type(T), ctxt(C), V1,V2,V3);
+headpat(T, V1, V2, V3) when is_atom(T) ->
+    headpat(type(T), l, V1, V2, V3);
+headpat(_, _, _, _) -> erlang:error(badarg).
+
+headpat(T, C, V1,V2,V3) ->
+    Rf = fun(Pos) ->
+		 {element,Pos,{element,1,{element,1,'$_'}}}
+	 end,
+    K2 = if T==n; T==a -> T;
+	    true -> '_'
+	 end,
+    {Kp,Vars} = case V1 of
+		    {Vt,Vc,Vn} ->
+			{T1,Vs1} = subst(T,Vt,fun() -> Rf(1) end,[]),
+			{C1,Vs2} = subst(C,Vc,fun() -> Rf(2) end,Vs1),
+			{{T1,C1,Vn}, Vs2};
+		    '_' ->
+			{{T,C,'_'}, []};
+		    _ ->
+			case is_var(V1) of
+			    true ->
+				{{T,C,'_'}, [{V1, {element,1,
+						   {element,1,'$_'}}}]};
+			    false ->
+				erlang:error(badarg)
+			end
+		end,
+    {{{Kp,K2},V2,V3}, Vars}.
+
+
+subst(X, '_', _F, Vs) ->
+    {X, Vs};
+subst(X, V, F, Vs) ->
+    case is_var(V) of
+	true ->
+	    {X, [{V,F()}|Vs]};
+	false ->
+	    {V, Vs}
+    end.
+
+ctxt(all)    -> '_';
+ctxt(global) -> g;
+ctxt(local)  -> l.
+
+type(all)   -> '_';
+type(names) -> n;
+type(props) -> p;
+type(counters) -> c;
+type(aggr_counters) -> a.
+
+keypat(Scope) ->
+    {C,T} = get_c_t(Scope),
+    {{T,C,'_'},'_'}.
+
+	     
+
+get_c_t({C,T}) -> {ctxt(C), type(T)};
+get_c_t(T) when is_atom(T) ->
+    {l, type(T)}.
+
+is_var('$1') -> true;
+is_var('$2') -> true;
+is_var('$3') -> true;
+is_var('$4') -> true;
+is_var('$5') -> true;
+is_var('$6') -> true;
+is_var('$7') -> true;
+is_var('$8') -> true;
+is_var('$9') -> true;
+is_var(X) when is_atom(X) ->
+    case atom_to_list(X) of
+	"$" ++ Tl ->
+	    try N = list_to_integer(Tl),
+		{true,N}
+	    catch
+		error:_ ->
+		    false
+	    end;
+	_ ->
+	    false
+    end;
+is_var(_) -> false.
+
+vars(N) when N > 3 ->
+    {'$1','$2','$3'};
+vars(_) ->
+    {'$4','$5','$6'}.
+
+
+rewrite(Gs, R) ->
+    [rewrite1(G, R) || G <- Gs].
+
+rewrite1('$_', _) ->
+    {{ {element,1,{element,1,'$_'}},
+       {element,2,'$_'},
+       {element,3,'$_'} }};
+rewrite1('$$', _) ->
+    [ {element,1,{element,1,'$_'}},
+      {element,2,'$_'},
+      {element,3,'$_'} ];
+rewrite1(Guard, R) when is_tuple(Guard) ->
+    list_to_tuple([rewrite1(G, R) || G <- tuple_to_list(Guard)]);
+rewrite1(Exprs, R) when is_list(Exprs) ->
+    [rewrite1(E, R) || E <- Exprs];
+rewrite1(V, R) when is_atom(V) ->
+    case is_var(V) of
+	true ->
+	    case lists:keysearch(V, 1, R) of
+		{value, {_, V1}} ->
+		    V1;
+		false ->
+		    V
+	    end;
+	false ->
+	    V
+    end;
+rewrite1(Expr, _) ->
+    Expr.
+
+
+table(Scope) ->
+    table(Scope, []).
+
+table(T, Opts) ->
+    [Traverse, NObjs] = [proplists:get_value(K,Opts,Def) ||
+			    {K,Def} <- [{traverse,select}, {n_objects,100}]],
+    TF = case Traverse of
+	     first_next ->
+		 fun() -> qlc_next(T, first(T)) end;
+	     last_prev -> fun() -> qlc_prev(T, last(T)) end;
+	     select ->
+		 fun(MS) -> qlc_select(select(T,MS,NObjs)) end;
+	     {select,MS} ->
+		 fun() -> qlc_select(select(T,MS,NObjs)) end;
+	     _ ->
+		 erlang:error(badarg, [T,Opts])
+	 end,
+    InfoFun = fun(indices) -> [2];
+		 (is_unique_objects) -> is_unique(T);
+		 (keypos) -> 1;
+		 (is_sorted_key) -> true;
+		 (num_of_objects) ->
+		      %% this is just a guesstimate.
+		      trunc(ets:info(?TAB,size) / 2.5)
+	      end,
+    LookupFun =
+	case Traverse of
+	    {select, _MS} -> undefined;
+	    _ -> fun(Pos, Ks) -> qlc_lookup(T, Pos, Ks) end
+	end,
+    qlc:table(TF, [{info_fun, InfoFun},
+		   {lookup_fun, LookupFun}] ++ [{K,V} || {K,V} <- Opts,
+							 K =/= traverse,
+							 K =/= n_objects]).
+qlc_lookup(_Scope, 1, Keys) ->
+    lists:flatmap(
+      fun(Key) ->
+	      ets:select(?TAB, [{ {{Key,'_'},'_','_'}, [],
+				    [{{ {element,1,{element,1,'$_'}},
+					{element,2,'$_'},
+					{element,3,'$_'} }}] }])
+      end, Keys);
+qlc_lookup(Scope, 2, Pids) ->
+    lists:flatmap(fun(Pid) ->
+			  Found =
+			      ets:select(?TAB, [{ {{Pid,keypat(Scope)}},
+						  [], ['$_']}]),
+			  lists:flatmap(
+			    fun({{_,{T,_,_}=K}}) ->
+				    K2 = if T==n; T==a -> T;
+					    true -> Pid
+					 end,
+				    case ets:lookup(?TAB, {K,K2}) of
+					[{{Key,_},_,Value}] ->
+					    [{Key, Pid, Value}];
+					[] ->
+					    []
+				    end
+			    end, Found)
+		  end, Pids).
+
+
+qlc_next(_, '$end_of_table') -> [];
+qlc_next(Scope, K) ->
+    case ets:lookup(?TAB, K) of
+	[{{Key,_}, Pid, V}] ->
+	    [{Key,Pid,V} | fun() -> qlc_next(Scope, next(Scope, K)) end];
+	[] ->
+	    qlc_next(Scope, next(Scope, K))
+    end.
+
+qlc_prev(_, '$end_of_table') -> [];
+qlc_prev(Scope, K) ->
+    case ets:lookup(?TAB, K) of
+	[{{Key,_},Pid,V}] ->
+	    [{Key,Pid,V} | fun() -> qlc_prev(Scope, prev(Scope, K)) end];
+	[] ->
+	    qlc_prev(Scope, prev(Scope, K))
+    end.
+
+qlc_select('$end_of_table') ->
+    [];
+qlc_select({Objects, Cont}) ->
+    Objects ++ fun() -> qlc_select(ets:select(Cont)) end.
+
+			 
+is_unique(names) -> true;
+is_unique(aggr_counters) -> true;
+is_unique({_, names}) -> true;
+is_unique({_, aggr_counters}) -> true;
+is_unique(n) -> true;
+is_unique(a) -> true;
+is_unique({_,n}) -> true;
+is_unique({_,a}) -> true;
+is_unique(_) -> false.
+     
diff --git a/lib/kernel/src/kernel.app.src b/lib/kernel/src/kernel.app.src
index 64b940a..011f743 100644
--- a/lib/kernel/src/kernel.app.src
+++ lib/kernel/src/kernel.app.src
@@ -27,6 +27,8 @@
 	     global,
 	     global_group,
 	     global_search,
+	     gproc,
+	     gen_leader,
 	     group,
 	     heart,
 	     hipe_unified_loader,
@@ -87,6 +89,7 @@
 		fixtable_server,
 		global_group,
 		global_name_server,
+		gproc,
 		heart,
 		init,
 		kernel_config,
diff --git a/lib/kernel/src/kernel.erl b/lib/kernel/src/kernel.erl
index bf16d8f..f39e117 100644
--- a/lib/kernel/src/kernel.erl
+++ lib/kernel/src/kernel.erl
@@ -28,6 +28,7 @@
 %%% Callback functions for the kernel application.
 %%%-----------------------------------------------------------------
 start(_, []) ->
+    {ok, _} = gproc:start_local(),
     case supervisor:start_link({local, kernel_sup}, kernel, []) of
 	{ok, Pid} ->
 	    Type = get_error_logger_type(),
@@ -125,6 +126,9 @@ init([]) ->
 		      permanent, infinity, supervisor,[erl_distribution]},
 	    DistAC = start_dist_ac(),
 
+	    GProc = {gproc, {gproc, go_global, []},
+		     permanent, 3000, worker, [gproc]},
+	    
 	    Timer = start_timer(),
 
 	    SafeSupervisor = {kernel_safe_sup,
@@ -135,7 +139,7 @@ init([]) ->
 	    {ok, {SupFlags,
 		  [Rpc, Global, InetDb | DistAC] ++ 
 		  [NetSup, Glo_grp, File, Code, 
-		   User, Config, SafeSupervisor] ++ Timer}}
+		   User, Config, GProc, SafeSupervisor] ++ Timer}}
     end;
 
 init(safe) ->
diff --git a/lib/stdlib/src/gen.erl b/lib/stdlib/src/gen.erl
index 1383f6a..861d6dc 100644
--- a/lib/stdlib/src/gen.erl
+++ lib/stdlib/src/gen.erl
@@ -25,7 +25,7 @@
 %%%-----------------------------------------------------------------
 -export([start/5, start/6, debug_options/1,
 	 call/3, call/4, reply/2]).
-
+-export([reg_behaviour/1]).
 -export([init_it/6, init_it/7]).
 
 -define(default_timeout, 5000).
@@ -87,6 +87,17 @@ do_spawn(GenMod, _, Name, Mod, Args, Options) ->
 		   spawn_opts(Options)).
 
 
+reg_behaviour(B) ->
+    catch begin
+	      Key = {p,l,behaviour},
+	      try gproc:reg(Key, B)
+	      catch
+		  error:badarg ->
+		      gproc:set_value(Key, B)
+	      end
+	  end.
+
+
 %%-----------------------------------------------------------------
 %% Initiate the new process.
 %% Register the name using the Rfunc function
diff --git a/lib/stdlib/src/gen_event.erl b/lib/stdlib/src/gen_event.erl
index a52ef7f..96c3201 100644
--- a/lib/stdlib/src/gen_event.erl
+++ lib/stdlib/src/gen_event.erl
@@ -122,6 +122,7 @@ init_it(Starter, self, Name, Mod, Args, Options) ->
     init_it(Starter, self(), Name, Mod, Args, Options);
 init_it(Starter, Parent, Name, _, _, Options) ->
     process_flag(trap_exit, true),
+    gen:reg_behaviour(?MODULE),
     Debug = gen:debug_options(Options),
     proc_lib:init_ack(Starter, {ok, self()}),
     loop(Parent, Name, [], Debug).
diff --git a/lib/stdlib/src/gen_fsm.erl b/lib/stdlib/src/gen_fsm.erl
index 2f81ffc..0404b23 100644
--- a/lib/stdlib/src/gen_fsm.erl
+++ lib/stdlib/src/gen_fsm.erl
@@ -313,6 +313,7 @@ init_it(Starter, self, Name, Mod, Args, Options) ->
     init_it(Starter, self(), Name, Mod, Args, Options);
 init_it(Starter, Parent, Name, Mod, Args, Options) ->
     Debug = gen:debug_options(Options),
+    gen:reg_behaviour(?MODULE),
     case catch Mod:init(Args) of
 	{ok, StateName, StateData} ->
 	    proc_lib:init_ack(Starter, {ok, self()}), 	    
diff --git a/lib/stdlib/src/gen_server.erl b/lib/stdlib/src/gen_server.erl
index aad5873..d1844b2 100644
--- a/lib/stdlib/src/gen_server.erl
+++ lib/stdlib/src/gen_server.erl
@@ -273,6 +273,7 @@ init_it(Starter, self, Name, Mod, Args, Options) ->
     init_it(Starter, self(), Name, Mod, Args, Options);
 init_it(Starter, Parent, Name, Mod, Args, Options) ->
     Debug = debug_options(Name, Options),
+    gen:reg_behaviour(?MODULE),
     case catch Mod:init(Args) of
 	{ok, State} ->
 	    proc_lib:init_ack(Starter, {ok, self()}), 	    
diff --git a/lib/stdlib/src/supervisor.erl b/lib/stdlib/src/supervisor.erl
index 3ed711e..fac763d 100644
--- a/lib/stdlib/src/supervisor.erl
+++ lib/stdlib/src/supervisor.erl
@@ -34,6 +34,8 @@
 
 -define(DICT, dict).
 
+	        
+
 -record(state, {name,
 		strategy,
 		children = [],
@@ -111,8 +113,10 @@ check_childspecs(X) -> {error, {badarg, X}}.
 %%% ---------------------------------------------------
 init({SupName, Mod, Args}) ->
     process_flag(trap_exit, true),
+    gen:reg_behaviour(?MODULE),
     case Mod:init(Args) of
 	{ok, {SupFlags, StartSpec}} ->
+	    gproc:reg({p,l,supflags}, SupFlags),
 	    case init_state(SupName, SupFlags, Mod, Args) of
 		{ok, State} when ?is_simple(State) ->
 		    init_dynamic(State, StartSpec);
@@ -131,8 +135,10 @@ init_children(State, StartSpec) ->
     SupName = State#state.name,
     case check_startspec(StartSpec) of
         {ok, Children} ->
+	    reg_children(Children),
             case start_children(Children, SupName) of
                 {ok, NChildren} ->
+		    set_children(NChildren),
                     {ok, State#state{children = NChildren}};
                 {error, NChildren} ->
                     terminate_children(NChildren, SupName),
@@ -142,9 +148,31 @@ init_children(State, StartSpec) ->
             {stop, {start_spec, Error}}
     end.
 
+
+reg_children(Children) ->
+    lists:foreach(
+      fun(Ch) ->
+	      gproc:reg({p,l,{childspec,Ch#child.name}}, Ch)
+      end, Children).
+
+set_children(Children) ->
+    lists:foreach(
+      fun(Ch) ->
+	      gproc:set_value({p,l,{childspec,Ch#child.name}}, Ch)
+      end, Children).
+
+unreg_child(Child) ->
+    gproc:unreg({p,l,{childspec,Child#child.name}}).
+
+set_child(Child) ->
+    catch gproc:set_value({p,l,{childspec,Child#child.name}}, Child).
+
+
+
 init_dynamic(State, [StartSpec]) ->
     case check_startspec([StartSpec]) of
         {ok, Children} ->
+	    reg_children(Children),
 	    {ok, State#state{children = Children}};
         Error ->
             {stop, {start_spec, Error}}
@@ -219,10 +247,12 @@ handle_call({start_child, EArgs}, _From, State) when ?is_simple(State) ->
     Args = A ++ EArgs,
     case do_start_child_i(M, F, Args) of
 	{ok, Pid} ->
+	    gproc:reg({p,l,{simple_child,Pid}}, Args),
 	    NState = State#state{dynamics = 
 				 ?DICT:store(Pid, Args, State#state.dynamics)},
 	    {reply, {ok, Pid}, NState};
 	{ok, Pid, Extra} ->
+	    gproc:reg({p,l,{simple_child,Pid}}, Args),
 	    NState = State#state{dynamics = 
 				 ?DICT:store(Pid, Args, State#state.dynamics)},
 	    {reply, {ok, Pid, Extra}, NState};
@@ -367,7 +397,8 @@ check_flags(What) ->
 
 update_childspec(State, StartSpec)  when ?is_simple(State) -> 
     case check_startspec(StartSpec) of                        
-        {ok, [Child]} ->                                      
+        {ok, [Child]} ->
+	    set_children([Child]),
             {ok, State#state{children = [Child]}};            
         Error ->                                              
             {error, Error}                                    
@@ -378,6 +409,7 @@ update_childspec(State, StartSpec) ->
 	{ok, Children} ->
 	    OldC = State#state.children, % In reverse start order !
 	    NewC = update_childspec1(OldC, Children, []),
+	    set_children(NewC),
 	    {ok, State#state{children = NewC}};
         Error ->
 	    {error, Error}
@@ -417,14 +449,18 @@ handle_start_child(Child, State) ->
 	    case do_start_child(State#state.name, Child) of
 		{ok, Pid} ->
 		    Children = State#state.children,
+		    NewChild = Child#child{pid = Pid},
+		    NewC = [NewChild|Children],
+		    set_child(NewChild),
 		    {{ok, Pid},
-		     State#state{children = 
-				 [Child#child{pid = Pid}|Children]}};
+		     State#state{children = NewC}};
 		{ok, Pid, Extra} ->
 		    Children = State#state.children,
+		    NewChild = Child#child{pid = Pid},
+		    NewC = [NewChild|Children],
+		    set_child(NewChild),
 		    {{ok, Pid, Extra},
-		     State#state{children = 
-				 [Child#child{pid = Pid}|Children]}};
+		     State#state{children = NewC}};
 		{error, What} ->
 		    {{error, {What, Child}}, State}
 	    end;
@@ -518,9 +554,11 @@ restart(rest_for_one, Child, State) ->
     ChAfter2 = terminate_children(ChAfter, State#state.name),
     case start_children(ChAfter2, State#state.name) of
 	{ok, ChAfter3} ->
-	    {ok, State#state{children = ChAfter3 ++ ChBefore}};
+	    NewC = ChAfter3 ++ ChBefore,
+	    {ok, State#state{children = NewC}};
 	{error, ChAfter3} ->
-	    restart(Child, State#state{children = ChAfter3 ++ ChBefore})
+	    NewC = ChAfter3 ++ ChBefore,
+	    restart(Child, State#state{children = NewC})
     end;
 restart(one_for_all, Child, State) ->
     Children1 = del_child(Child#child.pid, State#state.children),
@@ -544,6 +582,7 @@ terminate_children(Children, SupName) ->
 
 terminate_children([Child | Children], SupName, Res) ->
     NChild = do_terminate(Child, SupName),
+    set_child(NChild),
     terminate_children(Children, SupName, [NChild | Res]);
 terminate_children([], _SupName, Res) ->
     Res.
@@ -639,6 +678,7 @@ monitor_child(Pid) ->
 %% Child/State manipulating functions.
 %%-----------------------------------------------------------------
 state_del_child(#child{pid = Pid}, State) when ?is_simple(State) ->
+    gproc:unreg({p,l,{simple_child,Pid}}),
     NDynamics = ?DICT:erase(Pid, State#state.dynamics),
     State#state{dynamics = NDynamics};
 state_del_child(Child, State) ->
@@ -646,9 +686,13 @@ state_del_child(Child, State) ->
     State#state{children = NChildren}.
 
 del_child(Name, [Ch|Chs]) when Ch#child.name =:= Name ->
-    [Ch#child{pid = undefined} | Chs];
+    NewCh = Ch#child{pid = undefined},
+    set_child(NewCh),
+    [NewCh | Chs];
 del_child(Pid, [Ch|Chs]) when Ch#child.pid =:= Pid ->
-    [Ch#child{pid = undefined} | Chs];
+    NewCh = Ch#child{pid = undefined},
+    set_child(NewCh),
+    [NewCh | Chs];
 del_child(Name, [Ch|Chs]) ->
     [Ch|del_child(Name, Chs)];
 del_child(_, []) ->
@@ -675,12 +719,14 @@ replace_child(Child, State) ->
     State#state{children = Chs}.
 
 do_replace_child(Child, [Ch|Chs]) when Ch#child.name =:= Child#child.name ->
+    set_child(Child),
     [Child | Chs];
 do_replace_child(Child, [Ch|Chs]) ->
     [Ch|do_replace_child(Child, Chs)].
 
 remove_child(Child, State) ->
     Chs = lists:keydelete(Child#child.name, #child.name, State#state.children),
+    unreg_child(Child),
     State#state{children = Chs}.
 
 %%-----------------------------------------------------------------
diff --git a/lib/stdlib/src/sys.erl b/lib/stdlib/src/sys.erl
index 965bf0f..43e5177 100644
--- a/lib/stdlib/src/sys.erl
+++ lib/stdlib/src/sys.erl
@@ -24,6 +24,7 @@
 	 log/2, log/3, trace/2, trace/3, statistics/2, statistics/3,
 	 log_to_file/2, log_to_file/3, no_debug/1, no_debug/2,
 	 install/2, install/3, remove/2, remove/3]).
+-export([reg/3, reg/4]).
 -export([handle_system_msg/6, handle_debug/4,
 	 print_log/1, get_debug/3, debug_options/1]).
 
@@ -44,6 +45,11 @@ change_code(Name, Mod, Vsn, Extra) ->
 change_code(Name, Mod, Vsn, Extra, Timeout) ->
     send_system_msg(Name, {change_code, Mod, Vsn, Extra}, Timeout).
 
+reg(Name, Key, Value) ->
+    send_system_msg(Name, {reg, Key, Value}).
+reg(Name, Key, Value, Timeout) ->
+    send_system_msg(Name, {reg, Key, Value}, Timeout).
+
 %%-----------------------------------------------------------------
 %% Debug commands
 %%-----------------------------------------------------------------
@@ -187,6 +193,14 @@ do_cmd(_, suspend, _Parent, _Mod, Debug, Misc) ->
     {suspended, ok, Debug, Misc};
 do_cmd(_, resume, _Parent, _Mod, Debug, Misc) ->
     {running, ok, Debug, Misc};
+do_cmd(SysState, {reg, Key, Value}, _Parent, Mod, Debug, Misc) ->
+    Res = case erlang:function_exported(Mod, system_reg, 3) of
+	      true ->
+		  catch Mod:system_reg(Misc, Key, Value);
+	      false ->
+		  catch gproc:reg(Key, Value)
+	  end,
+    {SysState, Res, Debug, Misc};
 do_cmd(SysState, get_status, Parent, Mod, Debug, Misc) ->
     Res = get_status(SysState, Parent, Mod, Debug, Misc),
     {SysState, Res, Debug, Misc};
